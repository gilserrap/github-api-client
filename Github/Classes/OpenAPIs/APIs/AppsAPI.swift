//
// AppsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation



open class AppsAPI {
    /**
     Add a repository to an app installation
     
     - parameter installationId: (path) installation_id parameter 
     - parameter repositoryId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsAddRepoToInstallation(installationId: Int, repositoryId: Int, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        appsAddRepoToInstallationWithRequestBuilder(installationId: installationId, repositoryId: repositoryId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Add a repository to an app installation
     - PUT /user/installations/{installation_id}/repositories/{repository_id}
     - Add a single repository to an installation. The authenticated user must have admin access to the repository.  You must use a personal access token (which you can create via the [command line](https://docs.github.com/enterprise-server@3.0/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#add-a-repository-to-an-app-installation
}
     - parameter installationId: (path) installation_id parameter 
     - parameter repositoryId: (path)  
     - returns: RequestBuilder<Void> 
     */
    open class func appsAddRepoToInstallationWithRequestBuilder(installationId: Int, repositoryId: Int) -> RequestBuilder<Void> {
        var path = "/user/installations/{installation_id}/repositories/{repository_id}"
        let installationIdPreEscape = "\(APIHelper.mapValueToPathItem(installationId))"
        let installationIdPostEscape = installationIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{installation_id}", with: installationIdPostEscape, options: .literal, range: nil)
        let repositoryIdPreEscape = "\(APIHelper.mapValueToPathItem(repositoryId))"
        let repositoryIdPostEscape = repositoryIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repository_id}", with: repositoryIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "PUT", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Check an authorization
     
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter accessToken: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func appsCheckAuthorization(clientId: String, accessToken: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Authorization?,_ error: Error?) -> Void)) {
        appsCheckAuthorizationWithRequestBuilder(clientId: clientId, accessToken: accessToken).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Check an authorization
     - GET /applications/{client_id}/tokens/{access_token}
     - **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).  OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#check-an-authorization
}
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter accessToken: (path)  
     - returns: RequestBuilder<Authorization> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func appsCheckAuthorizationWithRequestBuilder(clientId: String, accessToken: String) -> RequestBuilder<Authorization> {
        var path = "/applications/{client_id}/tokens/{access_token}"
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{client_id}", with: clientIdPostEscape, options: .literal, range: nil)
        let accessTokenPreEscape = "\(APIHelper.mapValueToPathItem(accessToken))"
        let accessTokenPostEscape = accessTokenPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{access_token}", with: accessTokenPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Authorization>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Check a token
     
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject16: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsCheckToken(clientId: String, inlineObject16: InlineObject16? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Authorization?,_ error: Error?) -> Void)) {
        appsCheckTokenWithRequestBuilder(clientId: clientId, inlineObject16: inlineObject16).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Check a token
     - POST /applications/{client_id}/token
     - OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#check-a-token
}
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject16: (body)  (optional)
     - returns: RequestBuilder<Authorization> 
     */
    open class func appsCheckTokenWithRequestBuilder(clientId: String, inlineObject16: InlineObject16? = nil) -> RequestBuilder<Authorization> {
        var path = "/applications/{client_id}/token"
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{client_id}", with: clientIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject16)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Authorization>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create a content attachment
     
     - parameter contentReferenceId: (path)  
     - parameter inlineObject24: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsCreateContentAttachment(contentReferenceId: Int, inlineObject24: InlineObject24? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: ContentReferenceAttachment?,_ error: Error?) -> Void)) {
        appsCreateContentAttachmentWithRequestBuilder(contentReferenceId: contentReferenceId, inlineObject24: inlineObject24).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a content attachment
     - POST /content_references/{content_reference_id}/attachments
     - Creates an attachment under a content reference URL in the body or comment of an issue or pull request. Use the `id` of the content reference from the [`content_reference` event](https://docs.github.com/enterprise-server@3.0/webhooks/event-payloads/#content_reference) to create an attachment.  The app must create a content attachment within six hours of the content reference URL being posted. See \"[Using content attachments](https://docs.github.com/enterprise-server@3.0/apps/using-content-attachments/)\" for details about content attachments.  You must use an [installation access token](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#create-a-content-attachment
}
     - parameter contentReferenceId: (path)  
     - parameter inlineObject24: (body)  (optional)
     - returns: RequestBuilder<ContentReferenceAttachment> 
     */
    open class func appsCreateContentAttachmentWithRequestBuilder(contentReferenceId: Int, inlineObject24: InlineObject24? = nil) -> RequestBuilder<ContentReferenceAttachment> {
        var path = "/content_references/{content_reference_id}/attachments"
        let contentReferenceIdPreEscape = "\(APIHelper.mapValueToPathItem(contentReferenceId))"
        let contentReferenceIdPostEscape = contentReferenceIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{content_reference_id}", with: contentReferenceIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject24)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<ContentReferenceAttachment>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create a GitHub App from a manifest
     
     - parameter code: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsCreateFromManifest(code: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Integration?,_ error: Error?) -> Void)) {
        appsCreateFromManifestWithRequestBuilder(code: code).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a GitHub App from a manifest
     - POST /app-manifests/{code}/conversions
     - Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest flow](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/creating-github-apps-from-a-manifest/). When you create a GitHub App with the manifest flow, you receive a temporary `code` used to retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#create-a-github-app-from-a-manifest
}
     - parameter code: (path)  
     - returns: RequestBuilder<Integration> 
     */
    open class func appsCreateFromManifestWithRequestBuilder(code: String) -> RequestBuilder<Integration> {
        var path = "/app-manifests/{code}/conversions"
        let codePreEscape = "\(APIHelper.mapValueToPathItem(code))"
        let codePostEscape = codePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{code}", with: codePostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Integration>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Create an installation access token for an app
     
     - parameter installationId: (path) installation_id parameter 
     - parameter inlineObject14: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsCreateInstallationAccessToken(installationId: Int, inlineObject14: InlineObject14? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: InstallationToken?,_ error: Error?) -> Void)) {
        appsCreateInstallationAccessTokenWithRequestBuilder(installationId: installationId, inlineObject14: inlineObject14).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create an installation access token for an app
     - POST /app/installations/{installation_id}/access_tokens
     - Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.  You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#create-an-installation-access-token-for-an-app
}
     - parameter installationId: (path) installation_id parameter 
     - parameter inlineObject14: (body)  (optional)
     - returns: RequestBuilder<InstallationToken> 
     */
    open class func appsCreateInstallationAccessTokenWithRequestBuilder(installationId: Int, inlineObject14: InlineObject14? = nil) -> RequestBuilder<InstallationToken> {
        var path = "/app/installations/{installation_id}/access_tokens"
        let installationIdPreEscape = "\(APIHelper.mapValueToPathItem(installationId))"
        let installationIdPostEscape = installationIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{installation_id}", with: installationIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject14)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<InstallationToken>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Delete an app authorization
     
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject15: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsDeleteAuthorization(clientId: String, inlineObject15: InlineObject15? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        appsDeleteAuthorizationWithRequestBuilder(clientId: clientId, inlineObject15: inlineObject15).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete an app authorization
     - DELETE /applications/{client_id}/grant
     - OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's owner will be deleted. Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#delete-an-app-authorization
}
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject15: (body)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func appsDeleteAuthorizationWithRequestBuilder(clientId: String, inlineObject15: InlineObject15? = nil) -> RequestBuilder<Void> {
        var path = "/applications/{client_id}/grant"
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{client_id}", with: clientIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject15)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Delete an installation for the authenticated app
     
     - parameter installationId: (path) installation_id parameter 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsDeleteInstallation(installationId: Int, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        appsDeleteInstallationWithRequestBuilder(installationId: installationId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete an installation for the authenticated app
     - DELETE /app/installations/{installation_id}
     - Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily suspend an app's access to your account's resources, then we recommend the \"[Suspend an app installation](https://docs.github.com/enterprise-server@3.0/v3/apps/#suspend-an-app-installation)\" endpoint.  You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#delete-an-installation-for-the-authenticated-app
}
     - parameter installationId: (path) installation_id parameter 
     - returns: RequestBuilder<Void> 
     */
    open class func appsDeleteInstallationWithRequestBuilder(installationId: Int) -> RequestBuilder<Void> {
        var path = "/app/installations/{installation_id}"
        let installationIdPreEscape = "\(APIHelper.mapValueToPathItem(installationId))"
        let installationIdPostEscape = installationIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{installation_id}", with: installationIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Delete an app token
     
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject17: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsDeleteToken(clientId: String, inlineObject17: InlineObject17? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        appsDeleteTokenWithRequestBuilder(clientId: clientId, inlineObject17: inlineObject17).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete an app token
     - DELETE /applications/{client_id}/token
     - OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#delete-an-app-token
}
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject17: (body)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func appsDeleteTokenWithRequestBuilder(clientId: String, inlineObject17: InlineObject17? = nil) -> RequestBuilder<Void> {
        var path = "/applications/{client_id}/token"
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{client_id}", with: clientIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject17)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Get the authenticated app
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsGetAuthenticated(apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Integration?,_ error: Error?) -> Void)) {
        appsGetAuthenticatedWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get the authenticated app
     - GET /app
     - Returns the GitHub App associated with the authentication credentials used. To see how many app installations are associated with this GitHub App, see the `installations_count` in the response. For more details about your app's installations, see the \"[List installations for the authenticated app](https://docs.github.com/enterprise-server@3.0/rest/reference/apps#list-installations-for-the-authenticated-app)\" endpoint.  You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#get-the-authenticated-app
}
     - returns: RequestBuilder<Integration> 
     */
    open class func appsGetAuthenticatedWithRequestBuilder() -> RequestBuilder<Integration> {
        let path = "/app"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Integration>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get an app
     
     - parameter appSlug: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsGetBySlug(appSlug: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Integration?,_ error: Error?) -> Void)) {
        appsGetBySlugWithRequestBuilder(appSlug: appSlug).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get an app
     - GET /apps/{app_slug}
     - **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).  If the GitHub App you specify is public, you can access this endpoint without authenticating. If the GitHub App you specify is private, you must authenticate with a [personal access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or an [installation access token](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#get-an-app
}
     - parameter appSlug: (path)  
     - returns: RequestBuilder<Integration> 
     */
    open class func appsGetBySlugWithRequestBuilder(appSlug: String) -> RequestBuilder<Integration> {
        var path = "/apps/{app_slug}"
        let appSlugPreEscape = "\(APIHelper.mapValueToPathItem(appSlug))"
        let appSlugPostEscape = appSlugPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{app_slug}", with: appSlugPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Integration>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get an installation for the authenticated app
     
     - parameter installationId: (path) installation_id parameter 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsGetInstallation(installationId: Int, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Installation?,_ error: Error?) -> Void)) {
        appsGetInstallationWithRequestBuilder(installationId: installationId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get an installation for the authenticated app
     - GET /app/installations/{installation_id}
     - Enables an authenticated GitHub App to find an installation's information using the installation id. The installation's account type (`target_type`) will be either an organization or a user account, depending which account the repository belongs to.  You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#get-an-installation-for-the-authenticated-app
}
     - parameter installationId: (path) installation_id parameter 
     - returns: RequestBuilder<Installation> 
     */
    open class func appsGetInstallationWithRequestBuilder(installationId: Int) -> RequestBuilder<Installation> {
        var path = "/app/installations/{installation_id}"
        let installationIdPreEscape = "\(APIHelper.mapValueToPathItem(installationId))"
        let installationIdPostEscape = installationIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{installation_id}", with: installationIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Installation>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get an organization installation for the authenticated app
     
     - parameter org: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsGetOrgInstallation(org: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Installation?,_ error: Error?) -> Void)) {
        appsGetOrgInstallationWithRequestBuilder(org: org).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get an organization installation for the authenticated app
     - GET /orgs/{org}/installation
     - Enables an authenticated GitHub App to find the organization's installation information.  You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#get-an-organization-installation-for-the-authenticated-app
}
     - parameter org: (path)  
     - returns: RequestBuilder<Installation> 
     */
    open class func appsGetOrgInstallationWithRequestBuilder(org: String) -> RequestBuilder<Installation> {
        var path = "/orgs/{org}/installation"
        let orgPreEscape = "\(APIHelper.mapValueToPathItem(org))"
        let orgPostEscape = orgPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{org}", with: orgPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Installation>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a repository installation for the authenticated app
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsGetRepoInstallation(owner: String, repo: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Installation?,_ error: Error?) -> Void)) {
        appsGetRepoInstallationWithRequestBuilder(owner: owner, repo: repo).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a repository installation for the authenticated app
     - GET /repos/{owner}/{repo}/installation
     - Enables an authenticated GitHub App to find the repository's installation information. The installation's account type will be either an organization or a user account, depending which account the repository belongs to.  You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#get-a-repository-installation-for-the-authenticated-app
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - returns: RequestBuilder<Installation> 
     */
    open class func appsGetRepoInstallationWithRequestBuilder(owner: String, repo: String) -> RequestBuilder<Installation> {
        var path = "/repos/{owner}/{repo}/installation"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Installation>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a user installation for the authenticated app
     
     - parameter username: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsGetUserInstallation(username: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Installation?,_ error: Error?) -> Void)) {
        appsGetUserInstallationWithRequestBuilder(username: username).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a user installation for the authenticated app
     - GET /users/{username}/installation
     - Enables an authenticated GitHub App to find the user’s installation information.  You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#get-a-user-installation-for-the-authenticated-app
}
     - parameter username: (path)  
     - returns: RequestBuilder<Installation> 
     */
    open class func appsGetUserInstallationWithRequestBuilder(username: String) -> RequestBuilder<Installation> {
        var path = "/users/{username}/installation"
        let usernamePreEscape = "\(APIHelper.mapValueToPathItem(username))"
        let usernamePostEscape = usernamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{username}", with: usernamePostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Installation>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a webhook configuration for an app
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsGetWebhookConfigForApp(apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: WebhookConfig?,_ error: Error?) -> Void)) {
        appsGetWebhookConfigForAppWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a webhook configuration for an app
     - GET /app/hook/config
     - Returns the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see \"[Creating a GitHub App](/developers/apps/creating-a-github-app).\"  You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps#get-a-webhook-configuration-for-an-app
}
     - returns: RequestBuilder<WebhookConfig> 
     */
    open class func appsGetWebhookConfigForAppWithRequestBuilder() -> RequestBuilder<WebhookConfig> {
        let path = "/app/hook/config"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<WebhookConfig>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List repositories accessible to the user access token
     
     - parameter installationId: (path) installation_id parameter 
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsListInstallationReposForAuthenticatedUser(installationId: Int, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: InlineResponse20026?,_ error: Error?) -> Void)) {
        appsListInstallationReposForAuthenticatedUserWithRequestBuilder(installationId: installationId, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List repositories accessible to the user access token
     - GET /user/installations/{installation_id}/repositories
     - List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.  The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.  You must use a [user-to-server OAuth access token](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.  The access the user has to each repository is included in the hash under the `permissions` key.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#list-repositories-accessible-to-the-user-access-token
}
     - parameter installationId: (path) installation_id parameter 
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<InlineResponse20026> 
     */
    open class func appsListInstallationReposForAuthenticatedUserWithRequestBuilder(installationId: Int, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<InlineResponse20026> {
        var path = "/user/installations/{installation_id}/repositories"
        let installationIdPreEscape = "\(APIHelper.mapValueToPathItem(installationId))"
        let installationIdPostEscape = installationIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{installation_id}", with: installationIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<InlineResponse20026>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List installations for the authenticated app
     
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter since: (query) Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter outdated: (query)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsListInstallations(perPage: Int? = nil, page: Int? = nil, since: String? = nil, outdated: String? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Installation]?,_ error: Error?) -> Void)) {
        appsListInstallationsWithRequestBuilder(perPage: perPage, page: page, since: since, outdated: outdated).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List installations for the authenticated app
     - GET /app/installations
     - You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.  The permissions the installation has are included under the `permissions` key.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps/#list-installations-for-the-authenticated-app
}
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter since: (query) Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter outdated: (query)  (optional)
     - returns: RequestBuilder<[Installation]> 
     */
    open class func appsListInstallationsWithRequestBuilder(perPage: Int? = nil, page: Int? = nil, since: String? = nil, outdated: String? = nil) -> RequestBuilder<[Installation]> {
        let path = "/app/installations"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON(), 
            "since": since?.encodeToJSON(), 
            "outdated": outdated?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Installation]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List app installations accessible to the user access token
     
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsListInstallationsForAuthenticatedUser(perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: InlineResponse20011?,_ error: Error?) -> Void)) {
        appsListInstallationsForAuthenticatedUserWithRequestBuilder(perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List app installations accessible to the user access token
     - GET /user/installations
     - Lists installations of your GitHub App that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.  You must use a [user-to-server OAuth access token](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.  The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.  You can find the permissions for the installation under the `permissions` key.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#list-app-installations-accessible-to-the-user-access-token
}
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<InlineResponse20011> 
     */
    open class func appsListInstallationsForAuthenticatedUserWithRequestBuilder(perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<InlineResponse20011> {
        let path = "/user/installations"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<InlineResponse20011>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List repositories accessible to the app installation
     
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsListReposAccessibleToInstallation(perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: InlineResponse2005?,_ error: Error?) -> Void)) {
        appsListReposAccessibleToInstallationWithRequestBuilder(perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List repositories accessible to the app installation
     - GET /installation/repositories
     - List repositories that an app installation can access.  You must use an [installation access token](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#list-repositories-accessible-to-the-app-installation
}
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<InlineResponse2005> 
     */
    open class func appsListReposAccessibleToInstallationWithRequestBuilder(perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<InlineResponse2005> {
        let path = "/installation/repositories"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<InlineResponse2005>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Remove a repository from an app installation
     
     - parameter installationId: (path) installation_id parameter 
     - parameter repositoryId: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsRemoveRepoFromInstallation(installationId: Int, repositoryId: Int, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        appsRemoveRepoFromInstallationWithRequestBuilder(installationId: installationId, repositoryId: repositoryId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Remove a repository from an app installation
     - DELETE /user/installations/{installation_id}/repositories/{repository_id}
     - Remove a single repository from an installation. The authenticated user must have admin access to the repository.  You must use a personal access token (which you can create via the [command line](https://docs.github.com/enterprise-server@3.0/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#remove-a-repository-from-an-app-installation
}
     - parameter installationId: (path) installation_id parameter 
     - parameter repositoryId: (path)  
     - returns: RequestBuilder<Void> 
     */
    open class func appsRemoveRepoFromInstallationWithRequestBuilder(installationId: Int, repositoryId: Int) -> RequestBuilder<Void> {
        var path = "/user/installations/{installation_id}/repositories/{repository_id}"
        let installationIdPreEscape = "\(APIHelper.mapValueToPathItem(installationId))"
        let installationIdPostEscape = installationIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{installation_id}", with: installationIdPostEscape, options: .literal, range: nil)
        let repositoryIdPreEscape = "\(APIHelper.mapValueToPathItem(repositoryId))"
        let repositoryIdPostEscape = repositoryIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repository_id}", with: repositoryIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Reset an authorization
     
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter accessToken: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func appsResetAuthorization(clientId: String, accessToken: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Authorization?,_ error: Error?) -> Void)) {
        appsResetAuthorizationWithRequestBuilder(clientId: clientId, accessToken: accessToken).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Reset an authorization
     - POST /applications/{client_id}/tokens/{access_token}
     - **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).  OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the \"token\" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#reset-an-authorization
}
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter accessToken: (path)  
     - returns: RequestBuilder<Authorization> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func appsResetAuthorizationWithRequestBuilder(clientId: String, accessToken: String) -> RequestBuilder<Authorization> {
        var path = "/applications/{client_id}/tokens/{access_token}"
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{client_id}", with: clientIdPostEscape, options: .literal, range: nil)
        let accessTokenPreEscape = "\(APIHelper.mapValueToPathItem(accessToken))"
        let accessTokenPostEscape = accessTokenPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{access_token}", with: accessTokenPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Authorization>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Reset a token
     
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject18: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsResetToken(clientId: String, inlineObject18: InlineObject18? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Authorization?,_ error: Error?) -> Void)) {
        appsResetTokenWithRequestBuilder(clientId: clientId, inlineObject18: inlineObject18).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Reset a token
     - PATCH /applications/{client_id}/token
     - OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the \"token\" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#reset-a-token
}
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject18: (body)  (optional)
     - returns: RequestBuilder<Authorization> 
     */
    open class func appsResetTokenWithRequestBuilder(clientId: String, inlineObject18: InlineObject18? = nil) -> RequestBuilder<Authorization> {
        var path = "/applications/{client_id}/token"
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{client_id}", with: clientIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject18)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Authorization>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PATCH", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Revoke an authorization for an application
     
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter accessToken: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func appsRevokeAuthorizationForApplication(clientId: String, accessToken: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        appsRevokeAuthorizationForApplicationWithRequestBuilder(clientId: clientId, accessToken: accessToken).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Revoke an authorization for an application
     - DELETE /applications/{client_id}/tokens/{access_token}
     - **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).  OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#revoke-an-authorization-for-an-application
}
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter accessToken: (path)  
     - returns: RequestBuilder<Void> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func appsRevokeAuthorizationForApplicationWithRequestBuilder(clientId: String, accessToken: String) -> RequestBuilder<Void> {
        var path = "/applications/{client_id}/tokens/{access_token}"
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{client_id}", with: clientIdPostEscape, options: .literal, range: nil)
        let accessTokenPreEscape = "\(APIHelper.mapValueToPathItem(accessToken))"
        let accessTokenPostEscape = accessTokenPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{access_token}", with: accessTokenPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Revoke a grant for an application
     
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter accessToken: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func appsRevokeGrantForApplication(clientId: String, accessToken: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        appsRevokeGrantForApplicationWithRequestBuilder(clientId: clientId, accessToken: accessToken).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Revoke a grant for an application
     - DELETE /applications/{client_id}/grants/{access_token}
     - **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).  OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid token as `:access_token` and the grant for the token's owner will be deleted.  Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the Applications settings page under \"Authorized OAuth Apps\" on GitHub Enterprise Server](https://github.com/settings/applications#authorized).
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#revoke-a-grant-for-an-application
}
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter accessToken: (path)  
     - returns: RequestBuilder<Void> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func appsRevokeGrantForApplicationWithRequestBuilder(clientId: String, accessToken: String) -> RequestBuilder<Void> {
        var path = "/applications/{client_id}/grants/{access_token}"
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{client_id}", with: clientIdPostEscape, options: .literal, range: nil)
        let accessTokenPreEscape = "\(APIHelper.mapValueToPathItem(accessToken))"
        let accessTokenPostEscape = accessTokenPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{access_token}", with: accessTokenPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Revoke an installation access token
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsRevokeInstallationAccessToken(apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        appsRevokeInstallationAccessTokenWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Revoke an installation access token
     - DELETE /installation/token
     - Revokes the installation token you're using to authenticate as an installation and access this endpoint.  Once an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked installation token must have a new installation token to work. You can create a new token using the \"[Create an installation access token for an app](https://docs.github.com/enterprise-server@3.0/rest/reference/apps#create-an-installation-access-token-for-an-app)\" endpoint.  You must use an [installation access token](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#revoke-an-installation-access-token
}
     - returns: RequestBuilder<Void> 
     */
    open class func appsRevokeInstallationAccessTokenWithRequestBuilder() -> RequestBuilder<Void> {
        let path = "/installation/token"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Create a scoped access token
     
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject19: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsScopeToken(clientId: String, inlineObject19: InlineObject19? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Authorization?,_ error: Error?) -> Void)) {
        appsScopeTokenWithRequestBuilder(clientId: clientId, inlineObject19: inlineObject19).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a scoped access token
     - POST /applications/{client_id}/token/scoped
     - Exchanges a non-repository scoped user-to-server OAuth access token for a repository scoped user-to-server OAuth access token. You can specify which repositories the token can access and which permissions are granted to the token. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/apps#create-a-scoped-access-token
}
     - parameter clientId: (path) The client ID of your GitHub app. 
     - parameter inlineObject19: (body)  (optional)
     - returns: RequestBuilder<Authorization> 
     */
    open class func appsScopeTokenWithRequestBuilder(clientId: String, inlineObject19: InlineObject19? = nil) -> RequestBuilder<Authorization> {
        var path = "/applications/{client_id}/token/scoped"
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{client_id}", with: clientIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject19)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Authorization>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Update a webhook configuration for an app
     
     - parameter inlineObject13: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func appsUpdateWebhookConfigForApp(inlineObject13: InlineObject13? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: WebhookConfig?,_ error: Error?) -> Void)) {
        appsUpdateWebhookConfigForAppWithRequestBuilder(inlineObject13: inlineObject13).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Update a webhook configuration for an app
     - PATCH /app/hook/config
     - Updates the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see \"[Creating a GitHub App](/developers/apps/creating-a-github-app).\"  You must use a [JWT](https://docs.github.com/enterprise-server@3.0/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/v3/apps#update-a-webhook-configuration-for-an-app
}
     - parameter inlineObject13: (body)  (optional)
     - returns: RequestBuilder<WebhookConfig> 
     */
    open class func appsUpdateWebhookConfigForAppWithRequestBuilder(inlineObject13: InlineObject13? = nil) -> RequestBuilder<WebhookConfig> {
        let path = "/app/hook/config"
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject13)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<WebhookConfig>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PATCH", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

}
