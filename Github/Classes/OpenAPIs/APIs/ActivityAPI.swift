//
// ActivityAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation



open class ActivityAPI {
    /**
     Check if a repository is starred by the authenticated user
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityCheckRepoIsStarredByAuthenticatedUser(owner: String, repo: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        activityCheckRepoIsStarredByAuthenticatedUserWithRequestBuilder(owner: owner, repo: repo).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Check if a repository is starred by the authenticated user
     - GET /user/starred/{owner}/{repo}
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#check-if-a-repository-is-starred-by-the-authenticated-user
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - returns: RequestBuilder<Void> 
     */
    open class func activityCheckRepoIsStarredByAuthenticatedUserWithRequestBuilder(owner: String, repo: String) -> RequestBuilder<Void> {
        var path = "/user/starred/{owner}/{repo}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Delete a repository subscription
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityDeleteRepoSubscription(owner: String, repo: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        activityDeleteRepoSubscriptionWithRequestBuilder(owner: owner, repo: repo).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete a repository subscription
     - DELETE /repos/{owner}/{repo}/subscription
     - This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/enterprise-server@3.0/rest/reference/activity#set-a-repository-subscription).
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#delete-a-repository-subscription
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - returns: RequestBuilder<Void> 
     */
    open class func activityDeleteRepoSubscriptionWithRequestBuilder(owner: String, repo: String) -> RequestBuilder<Void> {
        var path = "/repos/{owner}/{repo}/subscription"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Delete a thread subscription
     
     - parameter threadId: (path) thread_id parameter 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityDeleteThreadSubscription(threadId: Int, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        activityDeleteThreadSubscriptionWithRequestBuilder(threadId: threadId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete a thread subscription
     - DELETE /notifications/threads/{thread_id}/subscription
     - Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/enterprise-server@3.0/rest/reference/activity#set-a-thread-subscription) endpoint and set `ignore` to `true`.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#delete-a-thread-subscription
}
     - parameter threadId: (path) thread_id parameter 
     - returns: RequestBuilder<Void> 
     */
    open class func activityDeleteThreadSubscriptionWithRequestBuilder(threadId: Int) -> RequestBuilder<Void> {
        var path = "/notifications/threads/{thread_id}/subscription"
        let threadIdPreEscape = "\(APIHelper.mapValueToPathItem(threadId))"
        let threadIdPostEscape = threadIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{thread_id}", with: threadIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get feeds
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityGetFeeds(apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Feed?,_ error: Error?) -> Void)) {
        activityGetFeedsWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get feeds
     - GET /feeds
     - GitHub Enterprise Server provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard)) format. The Feeds API lists all the feeds available to the authenticated user:  *   **Timeline**: The GitHub Enterprise Server global public timeline *   **User**: The public timeline for any user, using [URI template](https://docs.github.com/enterprise-server@3.0/rest/overview/resources-in-the-rest-api#hypermedia) *   **Current user public**: The public timeline for the authenticated user *   **Current user**: The private timeline for the authenticated user *   **Current user actor**: The private timeline for activity created by the authenticated user *   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of. *   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub Enterprise Server.  **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/enterprise-server@3.0/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use the older, non revocable auth tokens.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#get-feeds
}
     - returns: RequestBuilder<Feed> 
     */
    open class func activityGetFeedsWithRequestBuilder() -> RequestBuilder<Feed> {
        let path = "/feeds"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Feed>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a repository subscription
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityGetRepoSubscription(owner: String, repo: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: RepositorySubscription?,_ error: Error?) -> Void)) {
        activityGetRepoSubscriptionWithRequestBuilder(owner: owner, repo: repo).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a repository subscription
     - GET /repos/{owner}/{repo}/subscription
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#get-a-repository-subscription
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - returns: RequestBuilder<RepositorySubscription> 
     */
    open class func activityGetRepoSubscriptionWithRequestBuilder(owner: String, repo: String) -> RequestBuilder<RepositorySubscription> {
        var path = "/repos/{owner}/{repo}/subscription"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<RepositorySubscription>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a thread
     
     - parameter threadId: (path) thread_id parameter 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityGetThread(threadId: Int, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Thread?,_ error: Error?) -> Void)) {
        activityGetThreadWithRequestBuilder(threadId: threadId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a thread
     - GET /notifications/threads/{thread_id}
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#get-a-thread
}
     - parameter threadId: (path) thread_id parameter 
     - returns: RequestBuilder<Thread> 
     */
    open class func activityGetThreadWithRequestBuilder(threadId: Int) -> RequestBuilder<Thread> {
        var path = "/notifications/threads/{thread_id}"
        let threadIdPreEscape = "\(APIHelper.mapValueToPathItem(threadId))"
        let threadIdPostEscape = threadIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{thread_id}", with: threadIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Thread>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a thread subscription for the authenticated user
     
     - parameter threadId: (path) thread_id parameter 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityGetThreadSubscriptionForAuthenticatedUser(threadId: Int, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: ThreadSubscription?,_ error: Error?) -> Void)) {
        activityGetThreadSubscriptionForAuthenticatedUserWithRequestBuilder(threadId: threadId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a thread subscription for the authenticated user
     - GET /notifications/threads/{thread_id}/subscription
     - This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/enterprise-server@3.0/rest/reference/activity#get-a-repository-subscription).  Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#get-a-thread-subscription-for-the-authenticated-user
}
     - parameter threadId: (path) thread_id parameter 
     - returns: RequestBuilder<ThreadSubscription> 
     */
    open class func activityGetThreadSubscriptionForAuthenticatedUserWithRequestBuilder(threadId: Int) -> RequestBuilder<ThreadSubscription> {
        var path = "/notifications/threads/{thread_id}/subscription"
        let threadIdPreEscape = "\(APIHelper.mapValueToPathItem(threadId))"
        let threadIdPostEscape = threadIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{thread_id}", with: threadIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<ThreadSubscription>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List events for the authenticated user
     
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListEventsForAuthenticatedUser(username: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Event]?,_ error: Error?) -> Void)) {
        activityListEventsForAuthenticatedUserWithRequestBuilder(username: username, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List events for the authenticated user
     - GET /users/{username}/events
     - If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-events-for-the-authenticated-user
}
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Event]> 
     */
    open class func activityListEventsForAuthenticatedUserWithRequestBuilder(username: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Event]> {
        var path = "/users/{username}/events"
        let usernamePreEscape = "\(APIHelper.mapValueToPathItem(username))"
        let usernamePostEscape = usernamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{username}", with: usernamePostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Event]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List notifications for the authenticated user
     
     - parameter all: (query) If &#x60;true&#x60;, show notifications marked as read. (optional, default to false)
     - parameter participating: (query) If &#x60;true&#x60;, only shows notifications in which the user is directly participating or mentioned. (optional, default to false)
     - parameter since: (query) Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter before: (query) Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListNotificationsForAuthenticatedUser(all: Bool? = nil, participating: Bool? = nil, since: String? = nil, before: String? = nil, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Thread]?,_ error: Error?) -> Void)) {
        activityListNotificationsForAuthenticatedUserWithRequestBuilder(all: all, participating: participating, since: since, before: before, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List notifications for the authenticated user
     - GET /notifications
     - List all notifications for the current user, sorted by most recently updated.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-notifications-for-the-authenticated-user
}
     - parameter all: (query) If &#x60;true&#x60;, show notifications marked as read. (optional, default to false)
     - parameter participating: (query) If &#x60;true&#x60;, only shows notifications in which the user is directly participating or mentioned. (optional, default to false)
     - parameter since: (query) Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter before: (query) Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Thread]> 
     */
    open class func activityListNotificationsForAuthenticatedUserWithRequestBuilder(all: Bool? = nil, participating: Bool? = nil, since: String? = nil, before: String? = nil, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Thread]> {
        let path = "/notifications"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "all": all?.encodeToJSON(), 
            "participating": participating?.encodeToJSON(), 
            "since": since?.encodeToJSON(), 
            "before": before?.encodeToJSON(), 
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Thread]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List organization events for the authenticated user
     
     - parameter username: (path)  
     - parameter org: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListOrgEventsForAuthenticatedUser(username: String, org: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Event]?,_ error: Error?) -> Void)) {
        activityListOrgEventsForAuthenticatedUserWithRequestBuilder(username: username, org: org, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List organization events for the authenticated user
     - GET /users/{username}/events/orgs/{org}
     - This is the user's organization dashboard. You must be authenticated as the user to view this.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-organization-events-for-the-authenticated-user
}
     - parameter username: (path)  
     - parameter org: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Event]> 
     */
    open class func activityListOrgEventsForAuthenticatedUserWithRequestBuilder(username: String, org: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Event]> {
        var path = "/users/{username}/events/orgs/{org}"
        let usernamePreEscape = "\(APIHelper.mapValueToPathItem(username))"
        let usernamePostEscape = usernamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{username}", with: usernamePostEscape, options: .literal, range: nil)
        let orgPreEscape = "\(APIHelper.mapValueToPathItem(org))"
        let orgPostEscape = orgPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{org}", with: orgPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Event]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List public events
     
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListPublicEvents(perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Event]?,_ error: Error?) -> Void)) {
        activityListPublicEventsWithRequestBuilder(perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List public events
     - GET /events
     - We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-public-events
}
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Event]> 
     */
    open class func activityListPublicEventsWithRequestBuilder(perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Event]> {
        let path = "/events"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Event]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List public events for a network of repositories
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListPublicEventsForRepoNetwork(owner: String, repo: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Event]?,_ error: Error?) -> Void)) {
        activityListPublicEventsForRepoNetworkWithRequestBuilder(owner: owner, repo: repo, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List public events for a network of repositories
     - GET /networks/{owner}/{repo}/events
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-public-events-for-a-network-of-repositories
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Event]> 
     */
    open class func activityListPublicEventsForRepoNetworkWithRequestBuilder(owner: String, repo: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Event]> {
        var path = "/networks/{owner}/{repo}/events"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Event]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List public events for a user
     
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListPublicEventsForUser(username: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Event]?,_ error: Error?) -> Void)) {
        activityListPublicEventsForUserWithRequestBuilder(username: username, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List public events for a user
     - GET /users/{username}/events/public
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-public-events-for-a-user
}
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Event]> 
     */
    open class func activityListPublicEventsForUserWithRequestBuilder(username: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Event]> {
        var path = "/users/{username}/events/public"
        let usernamePreEscape = "\(APIHelper.mapValueToPathItem(username))"
        let usernamePostEscape = usernamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{username}", with: usernamePostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Event]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List public organization events
     
     - parameter org: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListPublicOrgEvents(org: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Event]?,_ error: Error?) -> Void)) {
        activityListPublicOrgEventsWithRequestBuilder(org: org, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List public organization events
     - GET /orgs/{org}/events
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-public-organization-events
}
     - parameter org: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Event]> 
     */
    open class func activityListPublicOrgEventsWithRequestBuilder(org: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Event]> {
        var path = "/orgs/{org}/events"
        let orgPreEscape = "\(APIHelper.mapValueToPathItem(org))"
        let orgPostEscape = orgPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{org}", with: orgPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Event]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List events received by the authenticated user
     
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListReceivedEventsForUser(username: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Event]?,_ error: Error?) -> Void)) {
        activityListReceivedEventsForUserWithRequestBuilder(username: username, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List events received by the authenticated user
     - GET /users/{username}/received_events
     - These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-events-received-by-the-authenticated-user
}
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Event]> 
     */
    open class func activityListReceivedEventsForUserWithRequestBuilder(username: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Event]> {
        var path = "/users/{username}/received_events"
        let usernamePreEscape = "\(APIHelper.mapValueToPathItem(username))"
        let usernamePostEscape = usernamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{username}", with: usernamePostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Event]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List public events received by a user
     
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListReceivedPublicEventsForUser(username: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Event]?,_ error: Error?) -> Void)) {
        activityListReceivedPublicEventsForUserWithRequestBuilder(username: username, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List public events received by a user
     - GET /users/{username}/received_events/public
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-public-events-received-by-a-user
}
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Event]> 
     */
    open class func activityListReceivedPublicEventsForUserWithRequestBuilder(username: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Event]> {
        var path = "/users/{username}/received_events/public"
        let usernamePreEscape = "\(APIHelper.mapValueToPathItem(username))"
        let usernamePostEscape = usernamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{username}", with: usernamePostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Event]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List repository events
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListRepoEvents(owner: String, repo: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Event]?,_ error: Error?) -> Void)) {
        activityListRepoEventsWithRequestBuilder(owner: owner, repo: repo, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List repository events
     - GET /repos/{owner}/{repo}/events
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-repository-events
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Event]> 
     */
    open class func activityListRepoEventsWithRequestBuilder(owner: String, repo: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Event]> {
        var path = "/repos/{owner}/{repo}/events"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Event]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List repository notifications for the authenticated user
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter all: (query) If &#x60;true&#x60;, show notifications marked as read. (optional, default to false)
     - parameter participating: (query) If &#x60;true&#x60;, only shows notifications in which the user is directly participating or mentioned. (optional, default to false)
     - parameter since: (query) Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter before: (query) Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListRepoNotificationsForAuthenticatedUser(owner: String, repo: String, all: Bool? = nil, participating: Bool? = nil, since: String? = nil, before: String? = nil, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Thread]?,_ error: Error?) -> Void)) {
        activityListRepoNotificationsForAuthenticatedUserWithRequestBuilder(owner: owner, repo: repo, all: all, participating: participating, since: since, before: before, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List repository notifications for the authenticated user
     - GET /repos/{owner}/{repo}/notifications
     - List all notifications for the current user.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-repository-notifications-for-the-authenticated-user
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter all: (query) If &#x60;true&#x60;, show notifications marked as read. (optional, default to false)
     - parameter participating: (query) If &#x60;true&#x60;, only shows notifications in which the user is directly participating or mentioned. (optional, default to false)
     - parameter since: (query) Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter before: (query) Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;. (optional)
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Thread]> 
     */
    open class func activityListRepoNotificationsForAuthenticatedUserWithRequestBuilder(owner: String, repo: String, all: Bool? = nil, participating: Bool? = nil, since: String? = nil, before: String? = nil, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Thread]> {
        var path = "/repos/{owner}/{repo}/notifications"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "all": all?.encodeToJSON(), 
            "participating": participating?.encodeToJSON(), 
            "since": since?.encodeToJSON(), 
            "before": before?.encodeToJSON(), 
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Thread]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_activityListReposStarredByAuthenticatedUser: String, CaseIterable {
        case created = "created"
        case updated = "updated"
    }

    /**
     * enum for parameter direction
     */
    public enum Direction_activityListReposStarredByAuthenticatedUser: String, CaseIterable {
        case asc = "asc"
        case desc = "desc"
    }

    /**
     List repositories starred by the authenticated user
     
     - parameter sort: (query) One of &#x60;created&#x60; (when the repository was starred) or &#x60;updated&#x60; (when it was last pushed to). (optional, default to .created)
     - parameter direction: (query) One of &#x60;asc&#x60; (ascending) or &#x60;desc&#x60; (descending). (optional, default to .desc)
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListReposStarredByAuthenticatedUser(sort: Sort_activityListReposStarredByAuthenticatedUser? = nil, direction: Direction_activityListReposStarredByAuthenticatedUser? = nil, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Repository]?,_ error: Error?) -> Void)) {
        activityListReposStarredByAuthenticatedUserWithRequestBuilder(sort: sort, direction: direction, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List repositories starred by the authenticated user
     - GET /user/starred
     - Lists repositories the authenticated user has starred.  You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.0/rest/overview/media-types/) via the `Accept` header:
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-repositories-starred-by-the-authenticated-user
}
     - parameter sort: (query) One of &#x60;created&#x60; (when the repository was starred) or &#x60;updated&#x60; (when it was last pushed to). (optional, default to .created)
     - parameter direction: (query) One of &#x60;asc&#x60; (ascending) or &#x60;desc&#x60; (descending). (optional, default to .desc)
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Repository]> 
     */
    open class func activityListReposStarredByAuthenticatedUserWithRequestBuilder(sort: Sort_activityListReposStarredByAuthenticatedUser? = nil, direction: Direction_activityListReposStarredByAuthenticatedUser? = nil, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Repository]> {
        let path = "/user/starred"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "sort": sort?.encodeToJSON(), 
            "direction": direction?.encodeToJSON(), 
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Repository]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_activityListReposStarredByUser: String, CaseIterable {
        case created = "created"
        case updated = "updated"
    }

    /**
     * enum for parameter direction
     */
    public enum Direction_activityListReposStarredByUser: String, CaseIterable {
        case asc = "asc"
        case desc = "desc"
    }

    /**
     List repositories starred by a user
     
     - parameter username: (path)  
     - parameter sort: (query) One of &#x60;created&#x60; (when the repository was starred) or &#x60;updated&#x60; (when it was last pushed to). (optional, default to .created)
     - parameter direction: (query) One of &#x60;asc&#x60; (ascending) or &#x60;desc&#x60; (descending). (optional, default to .desc)
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListReposStarredByUser(username: String, sort: Sort_activityListReposStarredByUser? = nil, direction: Direction_activityListReposStarredByUser? = nil, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [Repository]?,_ error: Error?) -> Void)) {
        activityListReposStarredByUserWithRequestBuilder(username: username, sort: sort, direction: direction, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List repositories starred by a user
     - GET /users/{username}/starred
     - Lists repositories a user has starred.  You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.0/rest/overview/media-types/) via the `Accept` header:
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-repositories-starred-by-a-user
}
     - parameter username: (path)  
     - parameter sort: (query) One of &#x60;created&#x60; (when the repository was starred) or &#x60;updated&#x60; (when it was last pushed to). (optional, default to .created)
     - parameter direction: (query) One of &#x60;asc&#x60; (ascending) or &#x60;desc&#x60; (descending). (optional, default to .desc)
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[Repository]> 
     */
    open class func activityListReposStarredByUserWithRequestBuilder(username: String, sort: Sort_activityListReposStarredByUser? = nil, direction: Direction_activityListReposStarredByUser? = nil, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[Repository]> {
        var path = "/users/{username}/starred"
        let usernamePreEscape = "\(APIHelper.mapValueToPathItem(username))"
        let usernamePostEscape = usernamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{username}", with: usernamePostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "sort": sort?.encodeToJSON(), 
            "direction": direction?.encodeToJSON(), 
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[Repository]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List repositories watched by a user
     
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListReposWatchedByUser(username: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [MinimalRepository]?,_ error: Error?) -> Void)) {
        activityListReposWatchedByUserWithRequestBuilder(username: username, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List repositories watched by a user
     - GET /users/{username}/subscriptions
     - Lists repositories a user is watching.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-repositories-watched-by-a-user
}
     - parameter username: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[MinimalRepository]> 
     */
    open class func activityListReposWatchedByUserWithRequestBuilder(username: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[MinimalRepository]> {
        var path = "/users/{username}/subscriptions"
        let usernamePreEscape = "\(APIHelper.mapValueToPathItem(username))"
        let usernamePostEscape = usernamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{username}", with: usernamePostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[MinimalRepository]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List stargazers
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListStargazersForRepo(owner: String, repo: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [SimpleUser]?,_ error: Error?) -> Void)) {
        activityListStargazersForRepoWithRequestBuilder(owner: owner, repo: repo, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List stargazers
     - GET /repos/{owner}/{repo}/stargazers
     - Lists the people that have starred the repository.  You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.0/rest/overview/media-types/) via the `Accept` header:
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-stargazers
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[SimpleUser]> 
     */
    open class func activityListStargazersForRepoWithRequestBuilder(owner: String, repo: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[SimpleUser]> {
        var path = "/repos/{owner}/{repo}/stargazers"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[SimpleUser]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List repositories watched by the authenticated user
     
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListWatchedReposForAuthenticatedUser(perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [MinimalRepository]?,_ error: Error?) -> Void)) {
        activityListWatchedReposForAuthenticatedUserWithRequestBuilder(perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List repositories watched by the authenticated user
     - GET /user/subscriptions
     - Lists repositories the authenticated user is watching.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-repositories-watched-by-the-authenticated-user
}
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[MinimalRepository]> 
     */
    open class func activityListWatchedReposForAuthenticatedUserWithRequestBuilder(perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[MinimalRepository]> {
        let path = "/user/subscriptions"
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[MinimalRepository]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List watchers
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityListWatchersForRepo(owner: String, repo: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [SimpleUser]?,_ error: Error?) -> Void)) {
        activityListWatchersForRepoWithRequestBuilder(owner: owner, repo: repo, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List watchers
     - GET /repos/{owner}/{repo}/subscribers
     - Lists the people watching the specified repository.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-watchers
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[SimpleUser]> 
     */
    open class func activityListWatchersForRepoWithRequestBuilder(owner: String, repo: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[SimpleUser]> {
        var path = "/repos/{owner}/{repo}/subscribers"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[SimpleUser]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Mark notifications as read
     
     - parameter inlineObject35: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityMarkNotificationsAsRead(inlineObject35: InlineObject35? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: InlineResponse2021?,_ error: Error?) -> Void)) {
        activityMarkNotificationsAsReadWithRequestBuilder(inlineObject35: inlineObject35).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Mark notifications as read
     - PUT /notifications
     - Marks all notifications as \"read\" removes it from the [default view on GitHub Enterprise Server](https://github.com/notifications). If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub Enterprise Server will run an asynchronous process to mark notifications as \"read.\" To check whether any \"unread\" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#mark-notifications-as-read
}
     - parameter inlineObject35: (body)  (optional)
     - returns: RequestBuilder<InlineResponse2021> 
     */
    open class func activityMarkNotificationsAsReadWithRequestBuilder(inlineObject35: InlineObject35? = nil) -> RequestBuilder<InlineResponse2021> {
        let path = "/notifications"
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject35)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<InlineResponse2021>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PUT", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Mark repository notifications as read
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject131: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityMarkRepoNotificationsAsRead(owner: String, repo: String, inlineObject131: InlineObject131? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        activityMarkRepoNotificationsAsReadWithRequestBuilder(owner: owner, repo: repo, inlineObject131: inlineObject131).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Mark repository notifications as read
     - PUT /repos/{owner}/{repo}/notifications
     - Marks all notifications in a repository as \"read\" removes them from the [default view on GitHub Enterprise Server](https://github.com/notifications). If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub Enterprise Server will run an asynchronous process to mark notifications as \"read.\" To check whether any \"unread\" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/enterprise-server@3.0/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#mark-repository-notifications-as-read
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject131: (body)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func activityMarkRepoNotificationsAsReadWithRequestBuilder(owner: String, repo: String, inlineObject131: InlineObject131? = nil) -> RequestBuilder<Void> {
        var path = "/repos/{owner}/{repo}/notifications"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject131)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "PUT", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Mark a thread as read
     
     - parameter threadId: (path) thread_id parameter 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityMarkThreadAsRead(threadId: Int, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        activityMarkThreadAsReadWithRequestBuilder(threadId: threadId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Mark a thread as read
     - PATCH /notifications/threads/{thread_id}
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#mark-a-thread-as-read
}
     - parameter threadId: (path) thread_id parameter 
     - returns: RequestBuilder<Void> 
     */
    open class func activityMarkThreadAsReadWithRequestBuilder(threadId: Int) -> RequestBuilder<Void> {
        var path = "/notifications/threads/{thread_id}"
        let threadIdPreEscape = "\(APIHelper.mapValueToPathItem(threadId))"
        let threadIdPostEscape = threadIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{thread_id}", with: threadIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "PATCH", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Set a repository subscription
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject154: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activitySetRepoSubscription(owner: String, repo: String, inlineObject154: InlineObject154? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: RepositorySubscription?,_ error: Error?) -> Void)) {
        activitySetRepoSubscriptionWithRequestBuilder(owner: owner, repo: repo, inlineObject154: inlineObject154).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Set a repository subscription
     - PUT /repos/{owner}/{repo}/subscription
     - If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/enterprise-server@3.0/rest/reference/activity#delete-a-repository-subscription) completely.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#set-a-repository-subscription
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject154: (body)  (optional)
     - returns: RequestBuilder<RepositorySubscription> 
     */
    open class func activitySetRepoSubscriptionWithRequestBuilder(owner: String, repo: String, inlineObject154: InlineObject154? = nil) -> RequestBuilder<RepositorySubscription> {
        var path = "/repos/{owner}/{repo}/subscription"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject154)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<RepositorySubscription>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PUT", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Set a thread subscription
     
     - parameter threadId: (path) thread_id parameter 
     - parameter inlineObject36: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activitySetThreadSubscription(threadId: Int, inlineObject36: InlineObject36? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: ThreadSubscription?,_ error: Error?) -> Void)) {
        activitySetThreadSubscriptionWithRequestBuilder(threadId: threadId, inlineObject36: inlineObject36).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Set a thread subscription
     - PUT /notifications/threads/{thread_id}/subscription
     - If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.  You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.  Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/enterprise-server@3.0/rest/reference/activity#delete-a-thread-subscription) endpoint.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#set-a-thread-subscription
}
     - parameter threadId: (path) thread_id parameter 
     - parameter inlineObject36: (body)  (optional)
     - returns: RequestBuilder<ThreadSubscription> 
     */
    open class func activitySetThreadSubscriptionWithRequestBuilder(threadId: Int, inlineObject36: InlineObject36? = nil) -> RequestBuilder<ThreadSubscription> {
        var path = "/notifications/threads/{thread_id}/subscription"
        let threadIdPreEscape = "\(APIHelper.mapValueToPathItem(threadId))"
        let threadIdPostEscape = threadIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{thread_id}", with: threadIdPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject36)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<ThreadSubscription>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PUT", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Star a repository for the authenticated user
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityStarRepoForAuthenticatedUser(owner: String, repo: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        activityStarRepoForAuthenticatedUserWithRequestBuilder(owner: owner, repo: repo).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Star a repository for the authenticated user
     - PUT /user/starred/{owner}/{repo}
     - Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/enterprise-server@3.0/rest/overview/resources-in-the-rest-api#http-verbs).\"
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#star-a-repository-for-the-authenticated-user
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - returns: RequestBuilder<Void> 
     */
    open class func activityStarRepoForAuthenticatedUserWithRequestBuilder(owner: String, repo: String) -> RequestBuilder<Void> {
        var path = "/user/starred/{owner}/{repo}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "PUT", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Unstar a repository for the authenticated user
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func activityUnstarRepoForAuthenticatedUser(owner: String, repo: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        activityUnstarRepoForAuthenticatedUserWithRequestBuilder(owner: owner, repo: repo).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Unstar a repository for the authenticated user
     - DELETE /user/starred/{owner}/{repo}
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/activity#unstar-a-repository-for-the-authenticated-user
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - returns: RequestBuilder<Void> 
     */
    open class func activityUnstarRepoForAuthenticatedUserWithRequestBuilder(owner: String, repo: String) -> RequestBuilder<Void> {
        var path = "/user/starred/{owner}/{repo}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

}
