//
// GitAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation



open class GitAPI {
    /**
     Create a blob
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject104: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitCreateBlob(owner: String, repo: String, inlineObject104: InlineObject104? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: ShortBlob?,_ error: Error?) -> Void)) {
        gitCreateBlobWithRequestBuilder(owner: owner, repo: repo, inlineObject104: inlineObject104).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a blob
     - POST /repos/{owner}/{repo}/git/blobs
     - responseHeaders: [Location(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#create-a-blob
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject104: (body)  (optional)
     - returns: RequestBuilder<ShortBlob> 
     */
    open class func gitCreateBlobWithRequestBuilder(owner: String, repo: String, inlineObject104: InlineObject104? = nil) -> RequestBuilder<ShortBlob> {
        var path = "/repos/{owner}/{repo}/git/blobs"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject104)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<ShortBlob>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create a commit
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject105: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitCreateCommit(owner: String, repo: String, inlineObject105: InlineObject105? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: GitCommit?,_ error: Error?) -> Void)) {
        gitCreateCommitWithRequestBuilder(owner: owner, repo: repo, inlineObject105: inlineObject105).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a commit
     - POST /repos/{owner}/{repo}/git/commits
     - Creates a new Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).  **Signature verification object**  The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:  | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. | | `signature` | `string` | The signature that was extracted from the commit. | | `payload` | `string` | The value that was signed. |  These are the possible values for `reason` in the `verification` object:  | Value | Description | | ----- | ----------- | | `expired_key` | The key that made the signature is expired. | | `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error communicating with the signature verification service. | | `gpgverify_unavailable` | The signature verification service is currently unavailable. | | `unsigned` | The object does not include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No user was associated with the `committer` email address in the commit. | | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. | | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. | | `unknown_key` | The key that made the signature has not been registered with any user's account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. | | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     - responseHeaders: [Location(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#create-a-commit
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject105: (body)  (optional)
     - returns: RequestBuilder<GitCommit> 
     */
    open class func gitCreateCommitWithRequestBuilder(owner: String, repo: String, inlineObject105: InlineObject105? = nil) -> RequestBuilder<GitCommit> {
        var path = "/repos/{owner}/{repo}/git/commits"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject105)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<GitCommit>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create a reference
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject106: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitCreateRef(owner: String, repo: String, inlineObject106: InlineObject106? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: GitRef?,_ error: Error?) -> Void)) {
        gitCreateRefWithRequestBuilder(owner: owner, repo: repo, inlineObject106: inlineObject106).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a reference
     - POST /repos/{owner}/{repo}/git/refs
     - Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
     - responseHeaders: [Location(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#create-a-reference
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject106: (body)  (optional)
     - returns: RequestBuilder<GitRef> 
     */
    open class func gitCreateRefWithRequestBuilder(owner: String, repo: String, inlineObject106: InlineObject106? = nil) -> RequestBuilder<GitRef> {
        var path = "/repos/{owner}/{repo}/git/refs"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject106)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<GitRef>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create a tag object
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject108: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitCreateTag(owner: String, repo: String, inlineObject108: InlineObject108? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: GitTag?,_ error: Error?) -> Void)) {
        gitCreateTagWithRequestBuilder(owner: owner, repo: repo, inlineObject108: inlineObject108).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a tag object
     - POST /repos/{owner}/{repo}/git/tags
     - Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then [create](https://docs.github.com/enterprise-server@3.0/rest/reference/git#create-a-reference) the `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.com/enterprise-server@3.0/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.  **Signature verification object**  The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:  | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. | | `signature` | `string` | The signature that was extracted from the commit. | | `payload` | `string` | The value that was signed. |  These are the possible values for `reason` in the `verification` object:  | Value | Description | | ----- | ----------- | | `expired_key` | The key that made the signature is expired. | | `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error communicating with the signature verification service. | | `gpgverify_unavailable` | The signature verification service is currently unavailable. | | `unsigned` | The object does not include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No user was associated with the `committer` email address in the commit. | | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. | | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. | | `unknown_key` | The key that made the signature has not been registered with any user's account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. | | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     - responseHeaders: [Location(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#create-a-tag-object
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject108: (body)  (optional)
     - returns: RequestBuilder<GitTag> 
     */
    open class func gitCreateTagWithRequestBuilder(owner: String, repo: String, inlineObject108: InlineObject108? = nil) -> RequestBuilder<GitTag> {
        var path = "/repos/{owner}/{repo}/git/tags"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject108)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<GitTag>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create a tree
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject109: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitCreateTree(owner: String, repo: String, inlineObject109: InlineObject109? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: GitTree?,_ error: Error?) -> Void)) {
        gitCreateTreeWithRequestBuilder(owner: owner, repo: repo, inlineObject109: inlineObject109).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a tree
     - POST /repos/{owner}/{repo}/git/trees
     - The tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that tree, this endpoint will overwrite the contents of the tree with the new path contents, and create a new tree structure.  If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then update a branch to point to the commit. For more information see \"[Create a commit](https://docs.github.com/enterprise-server@3.0/rest/reference/git#create-a-commit)\" and \"[Update a reference](https://docs.github.com/enterprise-server@3.0/rest/reference/git#update-a-reference).\"
     - responseHeaders: [Location(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#create-a-tree
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter inlineObject109: (body)  (optional)
     - returns: RequestBuilder<GitTree> 
     */
    open class func gitCreateTreeWithRequestBuilder(owner: String, repo: String, inlineObject109: InlineObject109? = nil) -> RequestBuilder<GitTree> {
        var path = "/repos/{owner}/{repo}/git/trees"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject109)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<GitTree>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Delete a reference
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter ref: (path) ref+ parameter 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitDeleteRef(owner: String, repo: String, ref: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Void?,_ error: Error?) -> Void)) {
        gitDeleteRefWithRequestBuilder(owner: owner, repo: repo, ref: ref).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete a reference
     - DELETE /repos/{owner}/{repo}/git/refs/{ref}
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#delete-a-reference
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter ref: (path) ref+ parameter 
     - returns: RequestBuilder<Void> 
     */
    open class func gitDeleteRefWithRequestBuilder(owner: String, repo: String, ref: String) -> RequestBuilder<Void> {
        var path = "/repos/{owner}/{repo}/git/refs/{ref}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let refPreEscape = "\(APIHelper.mapValueToPathItem(ref))"
        let refPostEscape = refPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{ref}", with: refPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Void>.Type = GithubAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a blob
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter fileSha: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitGetBlob(owner: String, repo: String, fileSha: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: Blob?,_ error: Error?) -> Void)) {
        gitGetBlobWithRequestBuilder(owner: owner, repo: repo, fileSha: fileSha).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a blob
     - GET /repos/{owner}/{repo}/git/blobs/{file_sha}
     - The `content` in the response will always be Base64 encoded.  _Note_: This API supports blobs up to 100 megabytes in size.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#get-a-blob
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter fileSha: (path)  
     - returns: RequestBuilder<Blob> 
     */
    open class func gitGetBlobWithRequestBuilder(owner: String, repo: String, fileSha: String) -> RequestBuilder<Blob> {
        var path = "/repos/{owner}/{repo}/git/blobs/{file_sha}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let fileShaPreEscape = "\(APIHelper.mapValueToPathItem(fileSha))"
        let fileShaPostEscape = fileShaPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{file_sha}", with: fileShaPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Blob>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a commit
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter commitSha: (path) commit_sha parameter 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitGetCommit(owner: String, repo: String, commitSha: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: GitCommit?,_ error: Error?) -> Void)) {
        gitGetCommitWithRequestBuilder(owner: owner, repo: repo, commitSha: commitSha).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a commit
     - GET /repos/{owner}/{repo}/git/commits/{commit_sha}
     - Gets a Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).  **Signature verification object**  The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:  | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. | | `signature` | `string` | The signature that was extracted from the commit. | | `payload` | `string` | The value that was signed. |  These are the possible values for `reason` in the `verification` object:  | Value | Description | | ----- | ----------- | | `expired_key` | The key that made the signature is expired. | | `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error communicating with the signature verification service. | | `gpgverify_unavailable` | The signature verification service is currently unavailable. | | `unsigned` | The object does not include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No user was associated with the `committer` email address in the commit. | | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. | | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. | | `unknown_key` | The key that made the signature has not been registered with any user's account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. | | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#get-a-commit
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter commitSha: (path) commit_sha parameter 
     - returns: RequestBuilder<GitCommit> 
     */
    open class func gitGetCommitWithRequestBuilder(owner: String, repo: String, commitSha: String) -> RequestBuilder<GitCommit> {
        var path = "/repos/{owner}/{repo}/git/commits/{commit_sha}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let commitShaPreEscape = "\(APIHelper.mapValueToPathItem(commitSha))"
        let commitShaPostEscape = commitShaPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{commit_sha}", with: commitShaPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<GitCommit>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a reference
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter ref: (path) ref+ parameter 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitGetRef(owner: String, repo: String, ref: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: GitRef?,_ error: Error?) -> Void)) {
        gitGetRefWithRequestBuilder(owner: owner, repo: repo, ref: ref).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a reference
     - GET /repos/{owner}/{repo}/git/ref/{ref}
     - Returns a single reference from your Git database. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an existing ref, a `404` is returned.  **Note:** You need to explicitly [request a pull request](https://docs.github.com/enterprise-server@3.0/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see \"[Checking mergeability of pull requests](https://docs.github.com/enterprise-server@3.0/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)\".
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#get-a-reference
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter ref: (path) ref+ parameter 
     - returns: RequestBuilder<GitRef> 
     */
    open class func gitGetRefWithRequestBuilder(owner: String, repo: String, ref: String) -> RequestBuilder<GitRef> {
        var path = "/repos/{owner}/{repo}/git/ref/{ref}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let refPreEscape = "\(APIHelper.mapValueToPathItem(ref))"
        let refPostEscape = refPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{ref}", with: refPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<GitRef>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a tag
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter tagSha: (path)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitGetTag(owner: String, repo: String, tagSha: String, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: GitTag?,_ error: Error?) -> Void)) {
        gitGetTagWithRequestBuilder(owner: owner, repo: repo, tagSha: tagSha).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a tag
     - GET /repos/{owner}/{repo}/git/tags/{tag_sha}
     - **Signature verification object**  The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:  | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. | | `signature` | `string` | The signature that was extracted from the commit. | | `payload` | `string` | The value that was signed. |  These are the possible values for `reason` in the `verification` object:  | Value | Description | | ----- | ----------- | | `expired_key` | The key that made the signature is expired. | | `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error communicating with the signature verification service. | | `gpgverify_unavailable` | The signature verification service is currently unavailable. | | `unsigned` | The object does not include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No user was associated with the `committer` email address in the commit. | | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. | | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. | | `unknown_key` | The key that made the signature has not been registered with any user's account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. | | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#get-a-tag
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter tagSha: (path)  
     - returns: RequestBuilder<GitTag> 
     */
    open class func gitGetTagWithRequestBuilder(owner: String, repo: String, tagSha: String) -> RequestBuilder<GitTag> {
        var path = "/repos/{owner}/{repo}/git/tags/{tag_sha}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let tagShaPreEscape = "\(APIHelper.mapValueToPathItem(tagSha))"
        let tagShaPostEscape = tagShaPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{tag_sha}", with: tagShaPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<GitTag>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get a tree
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter treeSha: (path)  
     - parameter recursive: (query) Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in &#x60;:tree_sha&#x60;. For example, setting &#x60;recursive&#x60; to any of the following will enable returning objects or subtrees: &#x60;0&#x60;, &#x60;1&#x60;, &#x60;\&quot;true\&quot;&#x60;, and &#x60;\&quot;false\&quot;&#x60;. Omit this parameter to prevent recursively returning objects or subtrees. (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitGetTree(owner: String, repo: String, treeSha: String, recursive: String? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: GitTree?,_ error: Error?) -> Void)) {
        gitGetTreeWithRequestBuilder(owner: owner, repo: repo, treeSha: treeSha, recursive: recursive).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a tree
     - GET /repos/{owner}/{repo}/git/trees/{tree_sha}
     - Returns a single tree using the SHA1 value for that tree.  If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree at a time.
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#get-a-tree
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter treeSha: (path)  
     - parameter recursive: (query) Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in &#x60;:tree_sha&#x60;. For example, setting &#x60;recursive&#x60; to any of the following will enable returning objects or subtrees: &#x60;0&#x60;, &#x60;1&#x60;, &#x60;\&quot;true\&quot;&#x60;, and &#x60;\&quot;false\&quot;&#x60;. Omit this parameter to prevent recursively returning objects or subtrees. (optional)
     - returns: RequestBuilder<GitTree> 
     */
    open class func gitGetTreeWithRequestBuilder(owner: String, repo: String, treeSha: String, recursive: String? = nil) -> RequestBuilder<GitTree> {
        var path = "/repos/{owner}/{repo}/git/trees/{tree_sha}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let treeShaPreEscape = "\(APIHelper.mapValueToPathItem(treeSha))"
        let treeShaPostEscape = treeShaPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{tree_sha}", with: treeShaPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "recursive": recursive?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<GitTree>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List matching references
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter ref: (path) ref+ parameter 
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitListMatchingRefs(owner: String, repo: String, ref: String, perPage: Int? = nil, page: Int? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: [GitRef]?,_ error: Error?) -> Void)) {
        gitListMatchingRefsWithRequestBuilder(owner: owner, repo: repo, ref: ref, perPage: perPage, page: page).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List matching references
     - GET /repos/{owner}/{repo}/git/matching-refs/{ref}
     - Returns an array of references from your Git database that match the supplied name. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be returned as an array.  When you use this endpoint without providing a `:ref`, it will return an array of all the references from your Git database, including notes and stashes if they exist on the server. Anything in the namespace is returned, not just `heads` and `tags`.  **Note:** You need to explicitly [request a pull request](https://docs.github.com/enterprise-server@3.0/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see \"[Checking mergeability of pull requests](https://docs.github.com/enterprise-server@3.0/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)\".  If you request matching references for a branch named `feature` but the branch `feature` doesn't exist, the response can still include other matching head refs that start with the word `feature`, such as `featureA` and `featureB`.
     - responseHeaders: [Link(String)]
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#list-matching-references
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter ref: (path) ref+ parameter 
     - parameter perPage: (query) Results per page (max 100) (optional, default to 30)
     - parameter page: (query) Page number of the results to fetch. (optional, default to 1)
     - returns: RequestBuilder<[GitRef]> 
     */
    open class func gitListMatchingRefsWithRequestBuilder(owner: String, repo: String, ref: String, perPage: Int? = nil, page: Int? = nil) -> RequestBuilder<[GitRef]> {
        var path = "/repos/{owner}/{repo}/git/matching-refs/{ref}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let refPreEscape = "\(APIHelper.mapValueToPathItem(ref))"
        let refPostEscape = refPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{ref}", with: refPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "per_page": perPage?.encodeToJSON(), 
            "page": page?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[GitRef]>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Update a reference
     
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter ref: (path) ref+ parameter 
     - parameter inlineObject107: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func gitUpdateRef(owner: String, repo: String, ref: String, inlineObject107: InlineObject107? = nil, apiResponseQueue: DispatchQueue = GithubAPI.apiResponseQueue, completion: @escaping ((_ data: GitRef?,_ error: Error?) -> Void)) {
        gitUpdateRefWithRequestBuilder(owner: owner, repo: repo, ref: ref, inlineObject107: inlineObject107).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Update a reference
     - PATCH /repos/{owner}/{repo}/git/refs/{ref}
     - externalDocs: class ExternalDocumentation {
    description: API method documentation
    url: https://docs.github.com/enterprise-server@3.0/rest/reference/git#update-a-reference
}
     - parameter owner: (path)  
     - parameter repo: (path)  
     - parameter ref: (path) ref+ parameter 
     - parameter inlineObject107: (body)  (optional)
     - returns: RequestBuilder<GitRef> 
     */
    open class func gitUpdateRefWithRequestBuilder(owner: String, repo: String, ref: String, inlineObject107: InlineObject107? = nil) -> RequestBuilder<GitRef> {
        var path = "/repos/{owner}/{repo}/git/refs/{ref}"
        let ownerPreEscape = "\(APIHelper.mapValueToPathItem(owner))"
        let ownerPostEscape = ownerPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{owner}", with: ownerPostEscape, options: .literal, range: nil)
        let repoPreEscape = "\(APIHelper.mapValueToPathItem(repo))"
        let repoPostEscape = repoPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{repo}", with: repoPostEscape, options: .literal, range: nil)
        let refPreEscape = "\(APIHelper.mapValueToPathItem(ref))"
        let refPostEscape = refPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{ref}", with: refPostEscape, options: .literal, range: nil)
        let URLString = GithubAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inlineObject107)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<GitRef>.Type = GithubAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PATCH", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

}
